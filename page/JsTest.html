<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>test 5</title>
    <style>
        h4 {
            text-align: center;
            color: darkslategrey;
        }
    </style>
    <script src="../js/testjs.js"></script>

    <script>
        function mydemoclick() {
            document.getElementById("demo").innerHTML = "这是一个函数";
        }

        function afterAllClick() {
            document.write(Date());

        }
    </script>
</head>
<body>
<p>DOM (Document Object Model)（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。</p>
<p>HTML 中的脚本必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间。
    <br>
    脚本可被放置在 HTML 页面的 &lt;body&gt; 和 &lt;head&gt; 部分中。</p>

<p>js直接写入输出流：</p>
<script>
    document.write("<h2>this is a title</h2>")
    document.write("<p>this is a paragraph</p>")
</script>
<p>
    <b>注意：</b>
    您只能在 HTML 输出流中使用 <strong>document.write</strong>。
    如果您在文档已加载后使用它（比如在函数中），会覆盖整个文档。
</p>
<p>nnerHTML则是DOM页面元素的一个属性，代表该元素的html内容。你可以精确到某一个具体的元素来进行更改。如果想修改document的内容，则需要修改document.documentElement.innerElement。
    <b>innerHTML很多情况下都优于document.write</b>
    ，其原因在于其允许更精确的控制要刷新页面的那一个部分。</p>
<br>
<hr>
<h4>dmmo</h4>
<p id="demo">this is some text </p>
<button type="button" onclick="buttonclick()"> click me</button>
<br>
<br>
<hr>
<h4>输出方式</h4>
<ol>


    <li>
        使用 window.alert() 弹出警告框。
    </li>
    <li>
        使用 document.write() 方法将内容写到 HTML 文档中。
    </li>
    <li> 使用 innerHTML 写入到 HTML 元素。</li>
    <LI> 使用 console.log() 写入到浏览器的控制台。
    </LI>
</ol>
<script>
    // window.alert(1+1);
    document.write(Date());
</script>
<p>
    请使用 document.write() 仅仅向文档输出写内容。
    <br>
    如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。eg：</p>

<button type="button" onclick="afterAllClick()">click me</button>
<br>
<script>
    a = 4;
    b = 9;
    c = a * b;
    console.log(c);
</script>
<p id="number">here will show some number</p>
<script>
    /*123e5就是123乘以10的5次方。*/
    var a = 123e5;
    document.getElementById("number").innerHTML = a;
    document.write("我是 \
换行");


</script>
<br>
tips: 大小写敏感 会忽略多余的空格 折行使用反折线\
<br>
语句标识符：
<br>
<img src="../img/js_biaoshifu.png" alt="biaoshifu.png" width="773" height="687">
<br>
<br>
<hr>
<h4>变量和数据格式</h4>
<ol>
    <li>
        <p>大小写敏感</p>

    </li>
    <li>
        一条声明语句可以声明多个变量 var a=123,b="123",c="haha"; 可换行，但是不能赋同一个值，eg:
        var x,y,z=1;这样写只有z是1，其它都是undefine;
    </li>
    <li>如果重新声明 JavaScript 变量，该变量的值不会丢失：
        <br>
        在以下两条语句执行后，变量 carname 的值依然是 "Volvo"：
        <br>
        var carname="Volvo";
        <br>
        var carname;
    </li>
    <li>
        Js数据类型
        -->字符串（String）、数字(Number)、布尔(Boolean)、数组(Array)、对象(Object)、空（Null）、未定义（Undefined）。
    </li>
    <li>动态类型，意味着相同的变量可用作不同的类型，eg var x; var x=5;var x="5"</li>
    <li>字符串-> "name is 'jhon'" / 'name is "jhon"'</li>
    <li>
        <p>数字 小数点不限制 极大和极小数可以使用科学计数法来写
            <br>
            var y=123e5; // 12300000
            <br>
            var z=123e-5; // 0.00123
        </p>
    </li>
    <li>undefined 和 null
        <p>
            Undefined 这个值表示变量不含有值。
            <br>
            可以通过将变量的值设置为 null 来清空变量。
            <br>
            实例
            <br>
            cars=null;
            person=null;</p></li>
    <li>声明变量类型
        <P>
            当您声明新变量时，可以使用关键词 "new" 来声明其类型：

        </P>
        <pre>
            var carname=new String;
            var x=      new Number;
            var y=      new Boolean;
            var cars=   new Array;
            var person= new Object;
            lamp	JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。
</pre>
    </li>
</ol>
<script>
    var person;
    var car = "Volvo";
    document.write(person + "<br>");
    document.write(car + "<br>");
    var car = null
    document.write(car + "<br>");
</script>
<br>
<br>
<hr>
<h4>调用带参的函数</h4>
<button onclick="functionwithPara('bill',20,'doctor')">click funcation with param</button>
<script>
    function functionwithPara(name, age, job) {
        alert(name + "-" + age + "-" + job);
    }
</script>
<br>
<br>
<hr>
<h4>带返回值的函数</h4>
<p>通过return 语句实现</p>
<p>在使用 return 语句时，函数会停止执行，并返回指定的值。但整个 Js 并不会停止执行，仅仅是函数。Js 将继续执行代码，从调用函数的地方</p>
<p id="testfun">testfun</p>
<script>
    function funWithreturn(var1) {
        return var1 * 2;
    }

    document.getElementById("testfun").innerHTML = funWithreturn(5);
</script>
<p>判断退出函数</p>
<form action="">
    a:
    <input type="text" name="a" id="a">
    <br>
    b:
    <input type="text" name="b" id="b">
    <br>
    <input type="submit" value="比较" onclick="compare(document.getElementById('a'),document.getElementById('b'))">


</form>
<script>
    function compare(vara, varb) {
        console.log("123-" + vara + "---" + varb);
        if (vara > varb) return;
        var x = vara + varb;
        alert(x);
    }
</script>
<!-------------------------------------------------------------------------------------->
<br>
<br>
<hr>
<h4>关于变量</h4>
<p>1.全局和局部变量属性及用法同java</p>
<p>2.如果把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。</p>
<p style="font-size: 14px">非严格模式下给未声明变量赋值创建的全局变量，是全局对象的可配置属性，可以删除。</p>
<p>3.如果变量在函数内没有声明。没有用var关键字，那么这个变量是全局变量</p>
<p>4.变量的生命周期 a.局部变量在函数执行完毕后销毁；b.全局变量在页面关闭后销毁</p>
<p>5.在html中，全局变量是window对象，所有的数据变量都属于window对象 eg:</p>
<p>
    在 HTML 中, 所有全局变量都会成为 window 变量。
</p>
<p id="demo5"></p>
<script>
    myFunction();
    document.getElementById("demo5").innerHTML =
        "我可以显示 " + window.carName;
    //在 myFunction() 被第一次调用之前， carName 变量是不存在的
    // 即 undefined。myFunction() 被调用过之后，carName 成为全局变量
    function myFunction() {
        carName = "Volvo";
    }
</script>
<p>6.你的全局变量，或者函数，可以覆盖 window 对象的变量或者函数。
    局部变量，包括 window 对象可以覆盖全局变量和函数。</p>
<script>
    var var1 = 1; // 不可配置全局属性
    var2 = 2; // 没有使用 var 声明，可配置全局属性

    console.log(this.var1); // 1
    console.log(window.var1); // 1

    delete var1; // false 无法删除
    console.log(var1); //1

    delete var2;
    console.log(delete var2); // true
    console.log(var2); // 已经删除 报错变量未定义
</script>

<p>全选实例：</p>

看书：<input type="checkbox" name="box" value="1"><br>
写字：<input type="checkbox" name="box" value="2"><br>
画画：<input type="checkbox" name="box" value="3"><br>
唱歌：<input type="checkbox" name="box" value="4"><br>
<button onclick="checkboxed('box','checkall')">全选</button>
<button onclick="checkboxed('box','reverscheckall')">烦选</button>
<button onclick="checkboxed('box','uncheckall')">取消全选</button>
<button onclick="checkallclick('box')">全选/取消</button>
<!-------------------------------------------------------------------------------------->
<br>
<br>
<hr>
<h4> ES6 中， let 关键字和 const 关键字</h4>
<pre>
1.let 的声明方式与 var 相同，用 let 来代替 var 来声明变量，就可以把变量限制在当前代码块中。

2.使用 const 声明的是常量，其值一旦被设定便不可被更改
</pre>
<p>
    <b>比较：</b>
    let 允许你声明一个作用域被限制在块级中的变量、语句或者表达式。<br>
    与var关键字不同的是，它声明的变量只能是全局或者整个函数块的 <br>
    let 声明的变量只在其声明的块或子块中可用，这一点，与 var 相似。<br>
    二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数 <br>
    eg：<br>
</p>
<script>
    function varTest() {
        var x = 1;
        if (true) {
            var x = 2;  // 同样的变量!
            console.log(x);  // 2
        }
        console.log(x);  // 2
    }

    function letTest() {
        let x = 1;
        if (true) {
            let x = 2;  // 不同的变量
            console.log(x);  // 2
        }
        console.log(x);  // 1
    }
</script>

<!-------------------------------------------------------------------------------------->
<br>
<br>
<hr>
<h4>html 事件</h4>
<ul>
    <li>HTML 页面完成加载</li>
    <li>input 字段改变时</li>
    <li>按钮被点击</li>
</ul>
<button onclick="getElementById('demo6').innerHTML=Date()">获取现在时间</button>
<P id="demo6">修改元素内容</P>

<button onclick="this.innerHTML=Date()">修改自身</button>
<!-------------------------------------------------------------------------------------->
<br>
<br>
<hr>
<h4>函数表达式</h4>
<pre>
    var x = function (a, b) {return a * b};

在函数表达式存储在变量后，变量也可作为一个函数使用：

实例
var x = function (a, b) {return a * b};
var z = x(4, 3);

    以上函数实际上是一个 匿名函数 (函数没有名称)。

函数存储在变量中，不需要函数名称，通常通过变量名来调用。
</pre>

<p>JavaScrip 内置构造函数。</p>
<p id="demo7"></p>
<script>
    var myFunction = new Function("a", "b", "return a * b");
    document.getElementById("demo7").innerHTML = myFunction(4, 3);
</script>
<p> 在 JavaScript 中，很多时候，你需要避免使用 new 关键字。</p>


<pre>
    <b>
      函数提升（Hoisting）
    </b>
    提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的的行为。

提升（Hoisting）应用在变量的声明与函数的声明。

因此，函数可以在声明之前调用：

    声明可以提升但是初始化不能提示  就是  var x 可以提升。var x=9;不能提升

    使用表达式定义函数时无法提升。
</pre>
<pre>
  <b>自调用函数</b>
函数表达式可以 "自调用"。

自调用表达式会自动调用。

如果表达式后面紧跟 () ，则会自动调用。

不能自调用声明的函数。即这样写的  function func(var1,var2){some code}  这只是一个声明

通过添加括号，来说明它是一个函数表达式：
    实例
(function () {
    var x = "Hello!!";      // 我将调用自己
})();
    以上函数实际上是一个 匿名自我调用的函数 (没有函数名)。
</pre>
<pre>
    JavaScript 函数作为一个值使用：

实例
function myFunction(a, b) {
    return a * b;
}

var x = myFunction(4, 3);

尝试一下 »
JavaScript 函数可作为表达式使用：

实例
function myFunction(a, b) {
    return a * b;
}

var x = myFunction(4, 3) * 2;
</pre>


<pre>
在 JavaScript 中使用 typeof 操作符判断函数类型将返回 "function" 。

但是JavaScript 函数描述为一个对象更加准确。

JavaScript 函数有 属性 和 方法。

arguments.length 属性返回函数调用过程接收到的参数个数：

实例
function myFunction(a, b) {
    return arguments.length;
}

尝试一下 »
toString() 方法将函数作为一个字符串返回:

实例
function myFunction(a, b) {
    return a * b;
}

var txt = myFunction.toString();
Note	函数定义作为对象的属性，称之为对象方法。
函数如果用于创建新的对象，称之为对象的构造函数。
</pre>

<br>
<br>
<br>
<pre>
    参数规则
JavaScript 函数定义时显式参数没有指定数据类型。

JavaScript 函数对隐式参数没有进行类型检测。

JavaScript 函数对隐式参数的个数没有进行检测。

默认参数
如果函数在调用时未提供隐式参数，参数会默认设置为： undefined

有时这是可以接受的，但是建议最好为参数设置一个默认值：

实例
function myFunction(x, y) {
    if (y === undefined) {
          y = 0;
    }
}

尝试一下 »
或者，更简单的方式：

实例
function myFunction(x, y) {
    y = y || 0;
}

Note	如果y已经定义 ， y || 返回 y, 因为 y 是 true, 否则返回 0, 因为 undefined 为 false。
如果函数调用时设置了过多的参数，参数将无法被引用，因为无法找到对应的参数名。 只能使用 arguments 对象来调用。
</pre>
<br><br><br><br>
<pre>
    Arguments 对象
JavaScript 函数有个内置的对象 arguments 对象。

argument 对象包含了函数调用的参数数组。

通过这种方式你可以很方便的找到最大的一个参数的值：

实例
x = findMax(1, 123, 500, 115, 44, 88);

function findMax() {
    var i, max = arguments[0];

    if(arguments.length < 2) return max;

    for (i = 0; i < arguments.length; i++) {
        if (arguments[i] > max) {
            max = arguments[i];
        }
    }
    return max;
}
</pre>
<pre>
    <strong>通过值传递参数</strong>
在函数中调用的参数是函数的隐式参数。

JavaScript 隐式参数通过值来传递：函数仅仅只是获取值。

如果函数修改参数的值，不会修改显式参数的初始值（在函数外定义）。

隐式参数的改变在函数外是不可见的。

<strong>通过对象传递参数</strong>
在JavaScript中，可以引用对象的值。

因此我们在函数内部修改对象的属性就会修改其初始的值。

修改对象属性可作用于函数外部（全局变量）。

修改对象属性在函数外是可见的。
</pre>
<pre>
    <strong>JavaScript 函数有 4 种调用方式。</strong>

每种方式的不同在于 this 的初始化。

this 关键字
一般而言，在Javascript中，this指向函数执行时的当前对象。
    在 HTML 中默认的全局对象是 HTML 页面本身，所以函数是属于 HTML 页面。

在浏览器中的页面对象是浏览器窗口(window 对象)。以上函数会自动变为 window 对象的函数。

myFunction() 和 window.myFunction() 是一样的：
</pre>
<pre>
    2.
    函数作为方法调用
在 JavaScript 中你可以将函数定义为对象的方法。

以下实例创建了一个对象 (myObject), 对象有两个属性 (firstName 和 lastName), 及一个方法 (fullName):

    函数作为对象方法调用，会使得 this 的值成为对象本身。
</pre>
<pre>
    4.如果函数调用前使用了 new 关键字, 则是调用了构造函数。

这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：

实例
// 构造函数:
function myFunction(arg1, arg2) {
    this.firstName = arg1;
    this.lastName  = arg2;
}

// This    creates a new object
var x = new myFunction("John","Doe");
x.firstName;                             // 返回 "John"

尝试一下 »
构造函数的调用会创建一个新的对象。新对象会继承构造函数的属性和方法。

Note	构造函数中 this 关键字没有任何的值。
this 的值在函数调用实例化对象(new object)时创建。</pre>


<pre>
    <strong>
        4.
作为函数方法调用函数
    </strong>
在 JavaScript 中, 函数是对象。JavaScript 函数有它的属性和方法。

call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。

实例
function myFunction(a, b) {
    return a * b;
}
myObject = myFunction.call(myObject, 10, 2);     // 返回 20

尝试一下 »

实例
function myFunction(a, b) {
    return a * b;
}
myArray = [10, 2];
myObject = myFunction.apply(myObject, myArray);  // 返回 20

尝试一下 »
两个方法都使用了对象本身作为第一个参数。 两者的区别在于第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。

在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。

在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。

Note	通过 call() 或 apply() 方法你可以设置 this 的值, 且作为已存在对象的新方法调用。
</pre>

<br><br>
<hr>
<h4>计数器demo1</h4>
<!--闭包其实是利用了一个变量退出作用域的时候，暂时没有被销毁，它的值还在，如果后面有变量也叫这个名字，那这个数据会被重新利用起来。你会发现，后面你使用的这个名字一样的变量是有初值的。下面的例子可以看出问题来。-->
<p>局部变量计数。</p>
<button type="button" onclick="myFunction()">计数!</button>
<p id="demo8">0</p>
<script>
    {
        var tmp = 2; //理论上在退出语句块后，这个变量要被释放掉的。包括内存可能被回收。但事实并非如此，会影响后面和他同名的变量
    }

    var add = (function () {
        //var counter = 0; //这里注释掉.其实和上面的tmp一样的道理。这里在函数自己执行完后就应该销毁了的。
        //return function () {return counter  += 1;} //这里的counter已经不是上面的counter了，是一个全局变量。有初值，受上面影响，初值为0
        return function () {return tmp += 1;} //这里tmp就是个全局变量。它是有初值的。为上面的2

    })();
    function myFunction(){
        document.getElementById("demo8").innerHTML = add();//3
        // document.getElementById("demo8").innerHTML = add();//4
        // document.getElementById("demo8").innerHTML = add(); //5
    }

</script>
<!--执行上面的代码可以看的很清楚。计数器一样正常工作。

所以，闭包就是利用了个bug: 退出作用域的变量不会立即销毁。会影响后面的同名变量。

但不知道后面的javascript版本会不会修改这种机制。

所以代码这么写是不可靠的。太依赖于javascript的内部实现了。

其实要实现全局计数器的需求。正常的做法是:

定义一个全局对象。这个对象定义自己的属性和方法add。

用的时候 对象.add 就可以了。这个才正常。

上面用闭包的方式太过巧妙，给人的感觉就是在夹缝中求生存。-->
<br><br><br><br>
<h4>demo2</h4>
<button type="button" onclick="myFunction()">计数!</button>
<p id="demo9">0</p>
<script>
    var add = new Object();
    add.count = 0;
    add.plus = function()
    {
        this.count++;
    }
    function myFunction(){
        add.plus();
        document.getElementById("demo9").innerHTML = add.count;
    }
</script>



</body>

</html>