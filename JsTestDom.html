<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>test 6</title>
    <style>
        h4 {
            color: chocolate;
            text-align: center;
        }

        #myDIV {
            background-color: coral;
            border: 1px solid;
            padding: 50px;
            color: white;
        }
    </style>
</head>
<body onload="checkCookie()">
<br>
<BR>
<HR>
<h4></h4>
<strong>
    查找 HTML 元素
</strong>
<p>
    通常，通过 JavaScript，您需要操作 HTML 元素。

</p>

为了做到这件事情，您必须首先找到该元素。有三种方法来做这件事：
<ul>
    <li>
        通过 id 找到 HTML 元素

    </li>
    <li>
        通过标签名找到 HTML 元素---getElementsByTagName('');

    </li>
    <li>
        通过类名找到 HTML 元素---getElementsByClassName('');

    </li>
</ul>
<!--本例查找 id="main" 的元素，然后查找 id="main" 元素中的所有 <p> 元素：-->
<div id="main">
    <p>该实例展示了 <b>getElementsByTagName</b> 方法</p>
    <p> DOM </p>
</div>
<script>
    var x = document.getElementById("main");
    var y = x.getElementsByTagName("p");
    document.write('id="main"元素中的第一个段落为：' + y[0].innerHTML);
</script>
<!--本例通过 getElementsByClassName 函数来查找 class="intro" 的元素-->
<p class="intro">你好!</p>
<p>该实例展示了 <b>getElementsByClassName</b> 方法!</p>
<script>
    x = document.getElementsByClassName("intro");
    document.write("<p>文本来自 class 为 intro 段落: " + x[0].innerHTML + "</p>");
</script>
<p><b>注意：</b>Internet Explorer 8 及更早 IE 版本不支持 getElementsByClassName() 方法。</p>
<br><br><BR>
<hr>
<h4>改变html</h4>
<ul>
    <li>
        改变内容-最简单的方法是使用 innerHTML 属性---
        <br>
        语法如下：document.getElementById(id).innerHTML=新的 HTML

    </li>
    <li>改变属性-
        <br>
        语法如下：document.getElementById(id).attribute=新属性值
    </li>
    <li>改变css <br>
        语法如下：document.getElementById(id).style.property=新样式
    </li>
    <li>
        对事件作出反应（下节）
    </li>
</ul>
<br>
demo:
<img src="img/icon.png" alt="icon.png" id="img" width="48" height="48">
<button onclick="changeImg()">change img</button>
<script>
    function changeImg() {
        document.getElementById("img").src = "img/icon_chen.png";
    }
</script>


<p id="p1"> this is text1</p>
<BUTTON onclick="changep1()">change p above</BUTTON>
<BUTTON onclick="visibiltyp1()">hide p above</BUTTON>
<!--style.visibility='hidden'-->
<script>

    function changep1() {
        document.getElementById("p1").style.color = "#ff0000";
    }

    function visibiltyp1() {
        document.getElementById("p1").style.visibility = "hidden";
    }
</script>
<br><br><BR>
<hr>
<h4>对事件的反应</h4>
<ol>
    <li>
        当用户点击鼠标时
    </li>
    <li>
        当网页已加载时
    </li>
    <li>
        当图像已加载时
    </li>
    <LI>
        当鼠标移动到元素上时
    </LI>
    <li>
        当输入字段被改变时 onchange 事件
    </li>
    <li>
        当提交 HTML 表单时
    </li>
    <li>
        当用户触发按键时
    </li>
</ol>

DEMO:
<script>
    function changeTEXT(id) {
        id.innerHTML = "i have changed---";
    }
</script>
<h5 onclick="changeTEXT(this)">
    cilck me to change text

</h5>
<p>分配事件</p>
<button onclick="" id="button2">click me to check</button>
<script>
    document.getElementById("button2").onclick = function () {
        displayBtnClick();
    }

    function displayBtnClick() {
        document.getElementById("button2").innerHTML = "yep  click success!";
    }
</script>
<pre>
    <strong>
    onload 和 onunload 事件
    </strong>
onload 和 onunload 事件会在用户进入或离开页面时被触发。
onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。
onload 和 onunload 事件可用于处理 cookie。
</pre>
<script>
    function checkCookie() {
        if (navigator.cookieEnabled == true) {
            alert("cookies 可用")
        } else {
            alert("cookies 不可用")
        }
    }
</script>
<script>
    function changeaToA() {
        var x = document.getElementById("a2A");
        x.value = x.value.toUpperCase();
    }
</script>
<input type="text" id="a2A" onchange="changeaToA()">
<p>当离开输入框后，函数将被触发，将小写字母转为大写字母。</p>


<pre>
    <strong>
    onmouseover 和 onmouseout 事件
    </strong>
可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。
</pre>
<div onmouseover="move(this)"
     onmouseout="out(this)" style="background-color: #5d9ab2;width: 100px;height: 100px;padding: 10px">
    mouse over me
</div>
<script>
    function move(obj) {
        obj.innerHTML = "when you move on ";
    }

    function out(obj) {
        obj.innerHTML = "mouse out";
    }
</script>
<pre>
    <strong>
    onmousedown、onmouseup 以及 onclick 事件
    </strong>
onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。

</pre>
<p>当输入框获取焦点时，修改背景色（background-color属性） 将被触发。</p>

<input type="text" onfocus="changebg(this)">
<script>
    function changebg(obj) {
        obj.style.background = "#eee"
    }

</script>

<pre>
    <strong>
     addEventListener() 方法用于向指定元素添加事件句柄。
    </strong>
addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。
你可以向一个元素添加多个事件句柄。
你可以向同个元素添加多个同类型的事件句柄，如：两个 "click" 事件。
你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。
addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。
当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。
你可以使用 removeEventListener() 方法来移除事件的监听。
</pre>
<p><strong>语法：</strong></p>
<pre>
element.addEventListener(event, function, useCapture);
第一个参数是事件的类型 (如 "click" 或 "mousedown").
第二个参数是事件触发后调用的函数。
第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。
注意:不要使用 "on" 前缀。 例如，使用 "click" ,而不是使用 "onclick"。
</pre>

<p>该实例使用 addEventListener() 方法在按钮中添加点击事件。 </p>
<button id="btn1">点我</button>
<p id="p"></p>
<script>
    document.getElementById("btn1").addEventListener("click", displayDate);

    function displayDate() {
        document.getElementById("p").innerHTML = Date();
    }
</script>

<button id="btn2">点我</button>
<script>
    document.getElementById("btn2").addEventListener("click", function () {
        alert("clicked")
    });

</script>
<p>该实例使用 addEventListener() 方法向同个按钮中添加两个点击事件。<br>
    不会覆盖，会按顺序执行</p>
<button id="btn3">点我</button>
<script>
    var x = document.getElementById("btn3");
    x.addEventListener("click", myFunction);
    x.addEventListener("click", someOtherFunction);

    function myFunction() {
        alert("Hello World!")
    }

    function someOtherFunction() {
        alert("函数已执行!")
    }
</script>


<p>实例演示了在使用 addEventListener() 方法时如何传递参数。</p>
<p>点击按钮执行计算。</p>
<button id="btn4">点我</button>
<p id="p3"></p>
<script>
    var p1 = 5;
    var p2 = 7;
    document.getElementById("btn4").addEventListener("click", function () {
        myFunction(p1, p2);
    });

    function myFunction(a, b) {
        var result = a * b;
        document.getElementById("p3").innerHTML = result;
    }
</script>
<pre>
    <strong>
    事件冒泡或事件捕获
    </strong>
事件传递有两种方式：冒泡与捕获。
事件传递定义了元素事件触发的顺序。 如果你将 <p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 "click" 事件先被触发呢？
在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： <p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。
在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： <div> 元素的点击事件先触发 ，然后再触发 <p> 元素的点击事件。
addEventListener() 方法可以指定 "useCapture" 参数来设置传递类型：
addEventListener(event, function, useCapture);
默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。
</pre>

<p>实例演示了在添加不同事件监听时，冒泡与捕获的不同。</p>
<div id="myDiv1">
    <p id="myP">点击段落，我是冒泡。</p>
</div>
<br>
<div id="myDiv2">
    <p id="myP2">点击段落，我是捕获。 </p>
</div>
<script>
    document.getElementById("myP").addEventListener("click", function () {
        alert("你点击了 P 元素!");
    }, false);
    document.getElementById("myDiv1").addEventListener("click", function () {
        alert(" 你点击了 DIV 元素 !");
    }, false);
    document.getElementById("myP2").addEventListener("click", function () {
        alert("你点击了 P2 元素!");
    }, true);
    document.getElementById("myDiv2").addEventListener("click", function () {
        alert("你点击了 DIV2 元素 !");
    }, true);
</script>

<pre>
    <strong>removeEventListener()
    </strong>
removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄:
</pre>

<div id="myDIV"> div 元素添加了 onmousemove 事件句柄，鼠标在桔红色的框内移动时会显示随机数。
    <p>点击按钮移除 DIV 的事件句柄。</p>
    <button onclick="removeHandler()" id="myBtn">点我</button>
</div>
<p id="demo"></p>
<script>
    document.getElementById("myDIV").addEventListener("mousemove", myFunction);

    function myFunction() {
        document.getElementById("demo").innerHTML = Math.random();
    }

    function removeHandler() {
        document.getElementById("myDIV").removeEventListener("mousemove", myFunction);
    }
</script>
<h4>DOM 元素 (节点)</h4>
<p>创建新的 HTML 元素 (节点) - appendChild()</p>

<div id="div1">
    <p id="p11">这是一个段落。</p>
    <p id="p12">这是另外一个段落。</p>
</div>

<script>
    //创建 <p> 元素:
    var para = document.createElement("p");
    //为 <p> 元素添加文本节点：
    var node = document.createTextNode("这是一个新的段落。");
    //将文本节点添加到 <p> 元素中：
    para.appendChild(node);
    //在一个已存在的元素中添加 p 元素。
    // 查找已存在的元素：
    var element = document.getElementById("div1");
    //添加到已存在的元素中:
    element.appendChild(para);
</script>
<p>创建新的 HTML 元素 (节点) - insertBefore()</p>
将新元素添加到开始位置
<br>
<div id="div2">
    <p id="p13">这是一个段落。</p>
    <p id="p14">这是另外一个段落。</p>
</div>

<script>
    var para = document.createElement("p");
    var node = document.createTextNode("这是一个新的段落。");
    para.appendChild(node);

    var element = document.getElementById("div2");
    var child = document.getElementById("p13");
    element.insertBefore(para, child);
</script>

<pre>
   <b>移除已存在的元素</b>
要移除一个元素，你需要知道该元素的父元素。
    <b>删除节点必须知道父节点</b>
</pre>
<div id="div5">
    <p id="p15">这是一个段落。</p>
    <p id="p16">这是另外一个段落。</p>
</div>

<script>
    var parent = document.getElementById("div5");
    var child = document.getElementById("p15");
    parent.removeChild(child);
</script>
<!--以下代码是已知要查找的子元素，然后查找其父元素，再删除这个子元素（删除节点必须知道父节点）：-->

<!--var child = document.getElementById("p1");-->
<!--child.parentNode.removeChild(child);-->
<div id="div6">
    <p id="p17">这是一个段落。</p>
    <p id="p18">这是另外一个段落。</p>
</div>

<script>
    var para = document.createElement("p");
    var node = document.createTextNode("这是一个新的段落。");
    para.appendChild(node);

    var parent = document.getElementById("div6");
    var child = document.getElementById("p17");
    parent.replaceChild(para, child);
</script>
<pre>
    HTMLCollection 对象
getElementsByTagName() 方法返回 HTMLCollection 对象。

HTMLCollection 对象类似 HTML 元素的一个数组。

以下代码获取文档所有的 P 元素：

实例
var x = document.getElementsByTagName("p");
集合中的元素可以通过索引(以 0 为起始位置)来访问

    集合 length 属性常用于遍历集合中的元素。

实例
修改所有 P 元素的背景颜色:

var myCollection = document.getElementsByTagName("p");
var i;
for (i = 0; i < myCollection.length; i++) {
    myCollection[i].style.backgroundColor = "red";
}

尝试一下 »
注意
HTMLCollection 不是一个数组！

HTMLCollection 看起来可能是一个数组，但其实不是。

你可以像数组一样，使用索引来获取元素。

HTMLCollection 无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。
</pre>
<PRE>
    NodeList 对象是一个从文档中获取的节点列表 (集合) 。

NodeList 对象类似 HTMLCollection 对象。

一些旧版本浏览器中的方法（如：getElementsByClassName()）返回的是 NodeList 对象，而不是 HTMLCollection 对象。

所有浏览器的 childNodes 属性返回的是 NodeList 对象。

大部分浏览器的 querySelectorAll() 返回 NodeList 对象。

以下代码选取了文档中所有的 P 节点：

实例
var myNodeList = document.querySelectorAll("p");
NodeList 中的元素可以通过索引(以 0 为起始位置)来访问。


    length 属性常用于遍历节点列表。

实例
修改节点列表中所有 P 元素的背景颜色:

var myNodelist = document.querySelectorAll("p");
var i;
for (i = 0; i < myNodelist.length; i++) {
    myNodelist[i].style.backgroundColor = "red";
}

</PRE>
<pre>
    HTMLCollection 与 NodeList 的区别
HTMLCollection 是 HTML 元素的集合。

NodeList 是一个文档节点的集合。

NodeList 与 HTMLCollection 有很多类似的地方。

NodeList 与 HTMLCollection 都与数组对象有点类似，可以使用索引 (0, 1, 2, 3, 4, ...) 来获取元素。

NodeList 与 HTMLCollection 都有 length 属性。

HTMLCollection 元素可以通过 name，id 或索引来获取。

NodeList 只能通过索引来获取。

只有 NodeList 对象有包含属性节点和文本节点。

节点列表不是一个数组！

节点列表看起来可能是一个数组，但其实不是。

你可以像数组一样，使用索引来获取元素。

节点列表无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。
</pre>

<PRE>
    pcoll=document.querySelectorAll("p")

plist=document.getElementsByTagName("p")
以上 pcoll 返回的就是固定的值。

而获取 plist 后, 若 html 页面有变化且刚好添加或移除了 p 标签, 此时plist也会跟着变。
</PRE>


<BR><br><br>
<hr>
<p>外层作用域无法读取内层作用域的变量</p>

<View>
    <Text>Hello world!</Text>
</View>
<p> es7 async/await </p>
async 使用：
<pre>
    异步函数声明：<br>
    async function methodmy(){}


    异步函数表达式：<br>
    const methodmy = async function(){}

    异步方法定义：<br>
    let obj = {async methodmy(){}}

    异步箭头函数：<br>
    const methodmy = async() => {}



</pre>

<br>
<hr>
<p><strong>
    tips es8
</strong></p>
<pre>
    1.es2017 结尾可以加逗号
    2.Object.entries 引入entry  对象实键值对的数据结构，每个键值对都是entry
    object.entries(x)强制将x转为对象，并以数组的方式返回其可枚举的自定义字符串
    Object.entries（{foo：1，bar：2}）

    [['foo'，1]，['bar'，2]]

与Object.entries非常相似，Object.values返回一个数组，其值为可枚举的字符串键值属性：

>> Object.values（{foo：1，bar：2}）

    [1，2]

两种方法的签名Object.entries( )和Object.values( )如下：

Object.entries（value：any）：Array <[string，any]>

Object.values（value：any）：Array &lt;any&gt;
========================================
    other explain:
    在ES8 /ES2017之前，Javascript开发者需要迭代一个对象的自身属性时候不得不用Object.keys，通过迭代且使用obj[key]获取value值返回一个数组：

let obj = {a: 1, b: 2, c: 3}
Object.keys(obj).forEach((key, index)=>{
  console.log(key, obj[key])
})
而使用ES6/ES2015 中for/of稍微好点：

let obj = {a: 1, b: 2, c: 3}
for (let key of Object.keys(obj)) {
  console.log(key, obj[key])
}
你使用老方式for/in(ES5)也许用的非常好。但是他会迭代所有可以枚举属性（像原型中的带名字的-see MDN）,不仅仅自己的属性，会意外的破坏那些 像prototype和tostring得到意想不到的值。
Object.values返回对象自身可以迭代属性值（values）为数组类型。我们最好使用Array.prototype.forEach迭代它，结合ES6的箭头函数隐形返回值：

let obj = {a: 1, b: 2, c: 3}
Object.values(obj).forEach(value=>console.log(value)) // 1, 2, 3
或者使用for/of:

let obj = {a: 1, b: 2, c: 3}
for (let value of Object.values(obj)) {
  console.log(value)
}
// 1, 2, 3
·Object.entries·，在另一方面，将会返回对象自身可迭代属性key-value对数组（作为一个数组），他们（key-value）分别以数组存放数组中。

let obj = {a: 1, b: 2, c: 3}
JSON.stringify(Object.entries(obj))
"[["a",1],["b",2],["c",3]]"
我们可以使用ES6/ES2015解构（需要深入了解解构请点击这篇文章和课程）,从这嵌套数组中分别声明key和value

let obj = {a: 1, b: 2, c: 3}
Object.entries(obj).forEach(([key, value]) => {
 console.log(`${key} is ${value}`)
})
// a is 1, b is 2, c is 3
你可以猜一猜，我们同样使用ES6for/of（毕竟全部都是数组）遍历Object.entries返回来的结果值。

let obj = {a: 1, b: 2, c: 3}
for (let [key, value] of Object.entries(obj)) {
  console.log(`${key} is ${value}`)
}
// a is 1, b is 2, c is 3
现在从对象中提取values和key-value pairs 变得非常容易了。Object.values和Object.entries这种方式不想之前 Object.keys(自身属性key+顺序相同)结合for/of(ES6)一起，我们不仅仅可以提取他们还可以迭代他们。



    ================================================
    3.字符串填充====引入了StringPadding规范功能，为JavaScript的一些本地方法提供了处理字符串功能。它提供了padStart和padEnd以及trimStart和trimEnd方法，从而使开发人员更好地控制字符串原语
    >>console.log('testing'.padStart(12).length)

  "     testing" is 12

>>console.log('testing'.padStart(12, '_'))

  "_____testing" is 12


    4.Object.getOwnPropertyDescriptors
ECMAScript中没有单个方法来简化两个对象之间的正确拷贝。之前，功能编程和不可变对象是复杂应用程序的重要组成部分，每个框架或库都在实现自己的样板，以便在合成对象或原型之间，能够正确复制属性。

Object.getOwnPropertyDescriptors()是一个复数函数Object.getOwnPropertyDescriptor()旨在简化JavaScript中复制对象的过程。
Object.defineProperties()这个新的规范功能的引入，允许decorators可以轻松地从另一个类或混合中提取出所有的描述符，并将它们分配给一个新的对象。

这个提案的部分原因，也是因为使用Object.assign()方法不够理想。Object.assign( )以吞噬行为的方式复制对象- 它直接访问属性和符号而不是其描述符。当涉及组合和处理复杂对象和类的原型时，这可能会成为一个更为危险的问题。

通过这个规范更新，开发人员不再需要依赖Object.assign()来复制对象，而是利用一个真正的浅层拷贝的创建：

// Given an object `obj`>> Object.create(

    Object.getPrototypeOf(obj),

    Object.getOwnPropertyDescriptors(obj)

  );



</pre>

<br>
<hr>
<p><strong>es7 </strong></p>
<pre>
    1.Array.prototype.includes
    替代indexOf，开发人员用来检查数组中是否存在值，indexOf是一种尴尬的使用，因为它返回一个元素在数组中的位置或者-1当这样的元素不能被找到的情况下。所以它返回一个数字，而不是一个布尔值。开发人员需要实施额外的检查。在ES6，要检查是否存在值你需要做一些如下图所示小技巧，因为他们没有匹配到值，Array.prototype.indexOf返回-1变成了true（转换成true），但是当匹配的元素为0位置时候，该数组包含元素，却变成了false

let arr = ['react', 'angular', 'vue']

// WRONG
if (arr.indexOf('react')) { // 0 -> evaluates to false, definitely as we expected
  console.log('Can use React') // this line would never be executed
}

// Correct
if (arr.indexOf('react') !== -1) {
  console.log('Can use React')
}

    在ES7中使用includes代码如下:

let arr = ['react', 'angular', 'vue']

// Correct
if (arr.includes('react')) {
  console.log('Can use React')
}

    includes第二可选参数fromIndex，它允许从特定位置开始寻找匹配。


    2.Exponentiation Operator(求幂运算)
    在ES6或者早些版本，你不得不创建一个循环，创建一个递归函数或者使用Math.pow
ES6/2015ES，你能使用Math.pow创建一个短的递归箭头函数

calculateExponent = (base, exponent) => base*((--exponent>1)?calculateExponent(base, exponent):base)
console.log(calculateExponent(7,12) === Math.pow(7,12)) // true
console.log(calculateExponent(2,7) === Math.pow(2,7)) // true

    在ES7 /ES2016，以数学向导的开发者可以使用更短的语法:

let a = 7 ** 12
let b = 2 ** 7
console.log(a === Math.pow(7,12)) // true
console.log(b === Math.pow(2,7)) // true


</pre>
</body>
</html>